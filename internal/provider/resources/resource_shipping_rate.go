// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/stripe/stripe-go/v84"
)

// ResourceShippingRate returns the schema for the stripe_shipping_rate resource
func ResourceShippingRate() *schema.Resource {
	return &schema.Resource{
		Description: "Shipping rates describe the price of shipping presented to your customers and applied to a purchase. For more information, see [Charge for shipping](https://stripe.com/docs/payments/during-payment/charge-shipping).",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"display_name": {
				Type:        schema.TypeString,
				Description: "The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.",
				Required:    true,
				ForceNew:    true,
			},
			"metadata": {
				Type:        schema.TypeMap,
				Description: "Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.",
				Optional:    true,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"tax_behavior": {
				Type:        schema.TypeString,
				Description: "Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.",
				Optional:    true,
				Computed:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"exclusive",
					"inclusive",
					"unspecified",
				}, false)),
			},
			"tax_code": {
				Type:        schema.TypeString,
				Description: "A [tax code](https://stripe.com/docs/tax/tax-categories) ID. The Shipping tax code is `txcd_92010001`.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"type": {
				Type:        schema.TypeString,
				Description: "The type of calculation to use on the shipping rate.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"fixed_amount",
				}, false)),
			},
			"delivery_estimate": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				ForceNew:    true,
				Description: "The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"maximum": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Optional:    true,
							ForceNew:    true,
							Description: "The upper bound of the estimated range. If empty, represents no upper bound i.e., infinite.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"unit": {
										Type:        schema.TypeString,
										Description: "A unit of time.",
										Required:    true,
										ForceNew:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"business_day",
											"day",
											"hour",
											"month",
											"week",
										}, false)),
									},
									"value": {
										Type:        schema.TypeInt,
										Description: "Must be greater than 0.",
										Required:    true,
										ForceNew:    true,
									},
								},
							},
						},
						"minimum": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Optional:    true,
							ForceNew:    true,
							Description: "The lower bound of the estimated range. If empty, represents no lower bound.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"unit": {
										Type:        schema.TypeString,
										Description: "A unit of time.",
										Required:    true,
										ForceNew:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"business_day",
											"day",
											"hour",
											"month",
											"week",
										}, false)),
									},
									"value": {
										Type:        schema.TypeInt,
										Description: "Must be greater than 0.",
										Required:    true,
										ForceNew:    true,
									},
								},
							},
						},
					},
				},
			},
			"fixed_amount": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Describes a fixed amount to charge for shipping. Must be present if type is `fixed_amount`.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"amount": {
							Type:        schema.TypeInt,
							Description: "A non-negative integer in cents representing how much to charge.",
							Required:    true,
							ForceNew:    true,
						},
						"currency": {
							Type:        schema.TypeString,
							Description: "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).",
							Required:    true,
							ForceNew:    true,
						},
						"currency_options": {
							Type:        schema.TypeList,
							Description: "Shipping rates defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).",
							Optional:    true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
									},
									"amount": {
										Type:        schema.TypeInt,
										Description: "A non-negative integer in cents representing how much to charge.",
										Required:    true,
									},
									"tax_behavior": {
										Type:        schema.TypeString,
										Description: "Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.",
										Optional:    true,
									},
								},
							},
						},
					},
				},
			},
		},

		CreateContext: resourceShippingRateCreate,
		ReadContext:   resourceShippingRateRead,
		UpdateContext: resourceShippingRateUpdate,
		DeleteContext: resourceShippingRateDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceShippingRateCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_shipping_rate resource")
	c := meta.(*stripe.Client)

	params := &stripe.ShippingRateCreateParams{}

	if v, ok := d.Get("display_name").(string); ok && v != "" {
		params.DisplayName = stripe.String(v)
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("tax_behavior").(string); ok && v != "" {
		params.TaxBehavior = stripe.String(v)
	}
	if v, ok := d.Get("tax_code").(string); ok && v != "" {
		params.TaxCode = stripe.String(v)
	}
	if v, ok := d.Get("type").(string); ok && v != "" {
		params.Type = stripe.String(v)
	}
	if v, ok := d.Get("delivery_estimate").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.DeliveryEstimate = &stripe.ShippingRateCreateDeliveryEstimateParams{}
		if v, ok := data["maximum"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.DeliveryEstimate.Maximum = &stripe.ShippingRateCreateDeliveryEstimateMaximumParams{}
			if val, ok := nestedData0["unit"].(string); ok && val != "" {
				params.DeliveryEstimate.Maximum.Unit = stripe.String(val)
			}
			if val, ok := nestedData0["value"].(int); ok {
				params.DeliveryEstimate.Maximum.Value = stripe.Int64(int64(val))
			}
		}
		if v, ok := data["minimum"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.DeliveryEstimate.Minimum = &stripe.ShippingRateCreateDeliveryEstimateMinimumParams{}
			if val, ok := nestedData0["unit"].(string); ok && val != "" {
				params.DeliveryEstimate.Minimum.Unit = stripe.String(val)
			}
			if val, ok := nestedData0["value"].(int); ok {
				params.DeliveryEstimate.Minimum.Value = stripe.Int64(int64(val))
			}
		}
	}
	if v, ok := d.Get("fixed_amount").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.FixedAmount = &stripe.ShippingRateCreateFixedAmountParams{}
		if val, ok := data["amount"].(int); ok {
			params.FixedAmount.Amount = stripe.Int64(int64(val))
		}
		if val, ok := data["currency"].(string); ok && val != "" {
			params.FixedAmount.Currency = stripe.String(val)
		}
		if v, ok := data["currency_options"].([]interface{}); ok && len(v) > 0 {
			params.FixedAmount.CurrencyOptions = make(map[string]*stripe.ShippingRateCreateFixedAmountCurrencyOptionsParams)
			for _, raw := range v {
				if item, ok := raw.(map[string]interface{}); ok {
					key, _ := item["key"].(string)
					if key == "" {
						continue
					}
					entry := &stripe.ShippingRateCreateFixedAmountCurrencyOptionsParams{}
					if val, ok := item["amount"].(int); ok {
						entry.Amount = stripe.Int64(int64(val))
					}
					if val, ok := item["tax_behavior"].(string); ok && val != "" {
						entry.TaxBehavior = stripe.String(val)
					}
					params.FixedAmount.CurrencyOptions[key] = entry
				}
			}
		}
	}
	shipping_rate, err := c.V1ShippingRates.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create shipping_rate: %w", err))
	}

	d.SetId(shipping_rate.ID)
	return resourceShippingRateRead(ctx, d, meta)
}

func resourceShippingRateRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_shipping_rate resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	shipping_rate, err := c.V1ShippingRates.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read shipping_rate: %w", err))
	}

	if err := d.Set("display_name", shipping_rate.DisplayName); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", shipping_rate.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("tax_behavior", shipping_rate.TaxBehavior); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("type", shipping_rate.Type); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if shipping_rate.TaxCode != nil {
		if err := d.Set("tax_code", shipping_rate.TaxCode.ID); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}
	if _, ok := d.GetOk("delivery_estimate"); ok {
		if shipping_rate.DeliveryEstimate != nil {
			nestedData := make(map[string]interface{})
			if shipping_rate.DeliveryEstimate.Maximum != nil {
				nestedData0 := make(map[string]interface{})
				nestedData0["unit"] = shipping_rate.DeliveryEstimate.Maximum.Unit
				nestedData0["value"] = int(shipping_rate.DeliveryEstimate.Maximum.Value)
				nestedData["maximum"] = []interface{}{nestedData0}
			}
			if shipping_rate.DeliveryEstimate.Minimum != nil {
				nestedData0 := make(map[string]interface{})
				nestedData0["unit"] = shipping_rate.DeliveryEstimate.Minimum.Unit
				nestedData0["value"] = int(shipping_rate.DeliveryEstimate.Minimum.Value)
				nestedData["minimum"] = []interface{}{nestedData0}
			}
			if len(nestedData) > 0 {
				if err := d.Set("delivery_estimate", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("fixed_amount"); ok {
		if shipping_rate.FixedAmount != nil {
			nestedData := make(map[string]interface{})
			nestedData["amount"] = int(shipping_rate.FixedAmount.Amount)
			if shipping_rate.FixedAmount.Currency != "" {
				nestedData["currency"] = shipping_rate.FixedAmount.Currency
			}
			if shipping_rate.FixedAmount.CurrencyOptions != nil && len(shipping_rate.FixedAmount.CurrencyOptions) > 0 {
				itemsData := make([]interface{}, 0, len(shipping_rate.FixedAmount.CurrencyOptions))
				for k, item := range shipping_rate.FixedAmount.CurrencyOptions {
					itemData := make(map[string]interface{})
					itemData["key"] = k
					itemData["amount"] = int(item.Amount)
					if item.TaxBehavior != "" {
						itemData["tax_behavior"] = item.TaxBehavior
					}
					if len(itemData) > 0 {
						itemsData = append(itemsData, itemData)
					}
				}
				if len(itemsData) > 0 {
					nestedData["currency_options"] = itemsData
				}
			}
			if len(nestedData) > 0 {
				if err := d.Set("fixed_amount", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	return diags
}

func resourceShippingRateUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_shipping_rate resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.ShippingRateUpdateParams{}

	if d.HasChange("metadata") {
		// Handle metadata updates including deletions
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = v.(string)
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = ""
			}
		}
	}
	if d.HasChange("tax_behavior") {
		if v, ok := d.Get("tax_behavior").(string); ok && v != "" {
			params.TaxBehavior = stripe.String(v)
		}
	}
	if d.HasChange("fixed_amount") {
		if v, ok := d.Get("fixed_amount").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.FixedAmount = &stripe.ShippingRateUpdateFixedAmountParams{}
			if v, ok := data["currency_options"].([]interface{}); ok && len(v) > 0 {
				params.FixedAmount.CurrencyOptions = make(map[string]*stripe.ShippingRateUpdateFixedAmountCurrencyOptionsParams)
				for _, raw := range v {
					if item, ok := raw.(map[string]interface{}); ok {
						key, _ := item["key"].(string)
						if key == "" {
							continue
						}
						entry := &stripe.ShippingRateUpdateFixedAmountCurrencyOptionsParams{}
						if val, ok := item["amount"].(int); ok {
							entry.Amount = stripe.Int64(int64(val))
						}
						if val, ok := item["tax_behavior"].(string); ok && val != "" {
							entry.TaxBehavior = stripe.String(val)
						}
						params.FixedAmount.CurrencyOptions[key] = entry
					}
				}
			}
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceShippingRateRead(ctx, d, meta)
	}

	_, err := c.V1ShippingRates.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update shipping_rate: %w", err))
	}

	return resourceShippingRateRead(ctx, d, meta)
}

func resourceShippingRateDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Marking stripe_shipping_rate as inactive instead of deleting", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.ShippingRateUpdateParams{
		Active: stripe.Bool(false),
	}

	_, err := c.V1ShippingRates.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to mark shipping_rate as inactive: %w", err))
	}

	tflog.Info(ctx, "stripe_shipping_rate marked as inactive successfully", map[string]interface{}{"id": d.Id()})
	d.SetId("")
	return nil
}
