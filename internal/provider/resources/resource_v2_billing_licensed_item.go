// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stripe/stripe-go/v84"
)

// ResourceV2BillingLicensedItem returns the schema for the stripe_v2_billing_licensed_item resource
func ResourceV2BillingLicensedItem() *schema.Resource {
	return &schema.Resource{
		Description: "A Licensed Item represents a billable item whose pricing is based on license fees. You can use license fees to specify the pricing and create subscriptions to these items.",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"display_name": {
				Type:        schema.TypeString,
				Description: "Description that customers will see in the invoice line item. Maximum length of 250 characters.",
				Required:    true,
			},
			"lookup_key": {
				Type:        schema.TypeString,
				Description: "An internal key you can use to search for a particular billable item. Must be unique among billable items. Maximum length of 200 characters.",
				Optional:    true,
				Computed:    true,
			},
			"metadata": {
				Type:        schema.TypeMap,
				Description: "Set of [key-value pairs](/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.",
				Optional:    true,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"unit_label": {
				Type:        schema.TypeString,
				Description: "The unit to use when displaying prices for this billable item in places like Checkout. For example, set this field to \\\"seat\\\" for Checkout to display \\\"(price) per seat\\\", or \\\"environment\\\" to display \\\"(price) per environment\\\". Maximum length of 100 characters.",
				Optional:    true,
				Computed:    true,
			},
		},

		CreateContext: resourceV2BillingLicensedItemCreate,
		ReadContext:   resourceV2BillingLicensedItemRead,
		UpdateContext: resourceV2BillingLicensedItemUpdate,
		DeleteContext: resourceV2BillingLicensedItemDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceV2BillingLicensedItemCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_v2_billing_licensed_item resource")
	c := meta.(*stripe.Client)

	params := &stripe.V2BillingLicensedItemCreateParams{}

	if v, ok := d.Get("display_name").(string); ok && v != "" {
		params.DisplayName = stripe.String(v)
	}
	if v, ok := d.Get("lookup_key").(string); ok && v != "" {
		params.LookupKey = stripe.String(v)
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("unit_label").(string); ok && v != "" {
		params.UnitLabel = stripe.String(v)
	}
	v2_billing_licensed_item, err := c.V2BillingLicensedItems.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create v2_billing_licensed_item: %w", err))
	}

	d.SetId(v2_billing_licensed_item.ID)
	return resourceV2BillingLicensedItemRead(ctx, d, meta)
}

func resourceV2BillingLicensedItemRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_v2_billing_licensed_item resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	v2_billing_licensed_item, err := c.V2BillingLicensedItems.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read v2_billing_licensed_item: %w", err))
	}

	if err := d.Set("display_name", v2_billing_licensed_item.DisplayName); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("lookup_key", v2_billing_licensed_item.LookupKey); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", v2_billing_licensed_item.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("unit_label", v2_billing_licensed_item.UnitLabel); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	return diags
}

func resourceV2BillingLicensedItemUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_v2_billing_licensed_item resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.V2BillingLicensedItemUpdateParams{}

	if d.HasChange("display_name") {
		if v, ok := d.Get("display_name").(string); ok && v != "" {
			params.DisplayName = stripe.String(v)
		}
	}
	if d.HasChange("lookup_key") {
		if v, ok := d.Get("lookup_key").(string); ok && v != "" {
			params.LookupKey = stripe.String(v)
		}
	}
	if d.HasChange("metadata") {
		// Handle metadata updates including deletions (V2 uses *string)
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]*string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = stripe.String(v.(string))
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = stripe.String("")
			}
		}
	}
	if d.HasChange("unit_label") {
		if v, ok := d.Get("unit_label").(string); ok && v != "" {
			params.UnitLabel = stripe.String(v)
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceV2BillingLicensedItemRead(ctx, d, meta)
	}

	_, err := c.V2BillingLicensedItems.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update v2_billing_licensed_item: %w", err))
	}

	return resourceV2BillingLicensedItemRead(ctx, d, meta)
}

func resourceV2BillingLicensedItemDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Warn(ctx, "stripe_v2_billing_licensed_item resources cannot be deleted via the Stripe API. "+
		"The resource will be removed from Terraform state but will remain in your Stripe account. "+
		"You may need to archive or deactivate it manually.",
		map[string]interface{}{"id": d.Id()})
	d.SetId("")
	return nil
}
