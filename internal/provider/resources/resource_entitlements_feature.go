// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stripe/stripe-go/v84"
)

// ResourceEntitlementsFeature returns the schema for the stripe_entitlements_feature resource
func ResourceEntitlementsFeature() *schema.Resource {
	return &schema.Resource{
		Description: "A feature represents a monetizable ability or functionality in your system. Features can be assigned to products, and when those products are purchased, Stripe will create an entitlement to the feature for the purchasing customer.",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"lookup_key": {
				Type:        schema.TypeString,
				Description: "A unique key you provide as your own system identifier. This may be up to 80 characters.",
				Required:    true,
				ForceNew:    true,
			},
			"metadata": {
				Type:        schema.TypeMap,
				Description: "Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.",
				Optional:    true,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Description: "The feature's name, for your own purpose, not meant to be displayable to the customer.",
				Required:    true,
			},
		},

		CreateContext: resourceEntitlementsFeatureCreate,
		ReadContext:   resourceEntitlementsFeatureRead,
		UpdateContext: resourceEntitlementsFeatureUpdate,
		DeleteContext: resourceEntitlementsFeatureDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceEntitlementsFeatureCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_entitlements_feature resource")
	c := meta.(*stripe.Client)

	params := &stripe.EntitlementsFeatureCreateParams{}

	if v, ok := d.Get("lookup_key").(string); ok && v != "" {
		params.LookupKey = stripe.String(v)
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("name").(string); ok && v != "" {
		params.Name = stripe.String(v)
	}
	entitlements_feature, err := c.V1EntitlementsFeatures.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create entitlements_feature: %w", err))
	}

	d.SetId(entitlements_feature.ID)
	return resourceEntitlementsFeatureRead(ctx, d, meta)
}

func resourceEntitlementsFeatureRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_entitlements_feature resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	entitlements_feature, err := c.V1EntitlementsFeatures.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read entitlements_feature: %w", err))
	}

	if err := d.Set("lookup_key", entitlements_feature.LookupKey); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", entitlements_feature.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("name", entitlements_feature.Name); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	return diags
}

func resourceEntitlementsFeatureUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_entitlements_feature resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.EntitlementsFeatureUpdateParams{}

	if d.HasChange("metadata") {
		// Handle metadata updates including deletions
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = v.(string)
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = ""
			}
		}
	}
	if d.HasChange("name") {
		if v, ok := d.Get("name").(string); ok && v != "" {
			params.Name = stripe.String(v)
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceEntitlementsFeatureRead(ctx, d, meta)
	}

	_, err := c.V1EntitlementsFeatures.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update entitlements_feature: %w", err))
	}

	return resourceEntitlementsFeatureRead(ctx, d, meta)
}

func resourceEntitlementsFeatureDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Warn(ctx, "stripe_entitlements_feature resources cannot be deleted via the Stripe API. "+
		"The resource will be removed from Terraform state but will remain in your Stripe account. "+
		"You may need to archive or deactivate it manually.",
		map[string]interface{}{"id": d.Id()})
	d.SetId("")
	return nil
}
