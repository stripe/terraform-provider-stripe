// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/stripe/stripe-go/v84"
)

// ResourcePromotionCode returns the schema for the stripe_promotion_code resource
func ResourcePromotionCode() *schema.Resource {
	return &schema.Resource{
		Description: "A Promotion Code represents a customer-redeemable code for an underlying promotion. You can create multiple codes for a single promotion. If you enable promotion codes in your [customer portal configuration](https://stripe.com/docs/customer-management/configure-portal), then customers can redeem a code themselves when updating a subscription in the portal. Customers can also view the currently active promotion codes and coupons on each of their subscriptions in the portal.",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"active": {
				Type:        schema.TypeBool,
				Description: "Whether the promotion code is currently active.",
				Optional:    true,
				Computed:    true,
			},
			"code": {
				Type:        schema.TypeString,
				Description: "The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. Valid characters are lower case letters (a-z), upper case letters (A-Z), and digits (0-9). If left blank, we will generate one automatically.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"customer": {
				Type:        schema.TypeString,
				Description: "The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"customer_account": {
				Type:        schema.TypeString,
				Description: "The account that this promotion code can be used by. If not set, the promotion code can be used by all accounts.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"expires_at": {
				Type:        schema.TypeInt,
				Description: "The timestamp at which this promotion code will expire. If the coupon has specified a `redeems_by`, then this value cannot be after the coupon's `redeems_by`.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"max_redemptions": {
				Type:        schema.TypeInt,
				Description: "A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a `max_redemptions`, then this value cannot be greater than the coupon's `max_redemptions`.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"metadata": {
				Type:        schema.TypeMap,
				Description: "Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.",
				Optional:    true,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"promotion": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Required:    true,
				ForceNew:    true,
				Description: "The promotion referenced by this promotion code.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"coupon": {
							Type:        schema.TypeString,
							Description: "If promotion `type` is `coupon`, the coupon for this promotion code.",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
						},
						"type": {
							Type:        schema.TypeString,
							Description: "Specifies the type of promotion.",
							Required:    true,
							ForceNew:    true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
								"coupon",
							}, false)),
						},
					},
				},
			},
			"restrictions": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Settings that restrict the redemption of the promotion code.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"currency_options": {
							Type:        schema.TypeList,
							Description: "Promotion codes defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).",
							Optional:    true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
									},
									"minimum_amount": {
										Type:        schema.TypeInt,
										Description: "Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).",
										Optional:    true,
									},
								},
							},
						},
						"first_time_transaction": {
							Type:        schema.TypeBool,
							Description: "A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
						},
						"minimum_amount": {
							Type:        schema.TypeInt,
							Description: "Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
						},
						"minimum_amount_currency": {
							Type:        schema.TypeString,
							Description: "Three-letter [ISO code](https://stripe.com/docs/currencies) for minimum_amount",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
						},
					},
				},
			},
		},

		CreateContext: resourcePromotionCodeCreate,
		ReadContext:   resourcePromotionCodeRead,
		UpdateContext: resourcePromotionCodeUpdate,
		DeleteContext: resourcePromotionCodeDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourcePromotionCodeCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_promotion_code resource")
	c := meta.(*stripe.Client)

	params := &stripe.PromotionCodeCreateParams{}

	if !d.GetRawConfig().GetAttr("active").IsNull() {
		params.Active = stripe.Bool(d.Get("active").(bool))
	}
	if v, ok := d.Get("code").(string); ok && v != "" {
		params.Code = stripe.String(v)
	}
	if v, ok := d.Get("customer").(string); ok && v != "" {
		params.Customer = stripe.String(v)
	}
	if v, ok := d.Get("customer_account").(string); ok && v != "" {
		params.CustomerAccount = stripe.String(v)
	}
	if !d.GetRawConfig().GetAttr("expires_at").IsNull() {
		params.ExpiresAt = stripe.Int64(int64(d.Get("expires_at").(int)))
	}
	if !d.GetRawConfig().GetAttr("max_redemptions").IsNull() {
		params.MaxRedemptions = stripe.Int64(int64(d.Get("max_redemptions").(int)))
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("promotion").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Promotion = &stripe.PromotionCodeCreatePromotionParams{}
		if val, ok := data["coupon"].(string); ok && val != "" {
			params.Promotion.Coupon = stripe.String(val)
		}
		if val, ok := data["type"].(string); ok && val != "" {
			params.Promotion.Type = stripe.String(val)
		}
	}
	if v, ok := d.Get("restrictions").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Restrictions = &stripe.PromotionCodeCreateRestrictionsParams{}
		if v, ok := data["currency_options"].([]interface{}); ok && len(v) > 0 {
			params.Restrictions.CurrencyOptions = make(map[string]*stripe.PromotionCodeCreateRestrictionsCurrencyOptionsParams)
			for _, raw := range v {
				if item, ok := raw.(map[string]interface{}); ok {
					key, _ := item["key"].(string)
					if key == "" {
						continue
					}
					entry := &stripe.PromotionCodeCreateRestrictionsCurrencyOptionsParams{}
					if val, ok := item["minimum_amount"].(int); ok {
						entry.MinimumAmount = stripe.Int64(int64(val))
					}
					params.Restrictions.CurrencyOptions[key] = entry
				}
			}
		}
		if val, ok := data["first_time_transaction"].(bool); ok {
			params.Restrictions.FirstTimeTransaction = stripe.Bool(val)
		}
		if val, ok := data["minimum_amount"].(int); ok && val > 0 {
			params.Restrictions.MinimumAmount = stripe.Int64(int64(val))
		}
		if val, ok := data["minimum_amount_currency"].(string); ok && val != "" {
			params.Restrictions.MinimumAmountCurrency = stripe.String(val)
		}
	}
	promotion_code, err := c.V1PromotionCodes.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create promotion_code: %w", err))
	}

	d.SetId(promotion_code.ID)
	return resourcePromotionCodeRead(ctx, d, meta)
}

func resourcePromotionCodeRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_promotion_code resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	promotion_code, err := c.V1PromotionCodes.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read promotion_code: %w", err))
	}

	if err := d.Set("active", promotion_code.Active); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("code", promotion_code.Code); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("customer", promotion_code.Customer); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("customer_account", promotion_code.CustomerAccount); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("expires_at", promotion_code.ExpiresAt); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("max_redemptions", promotion_code.MaxRedemptions); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", promotion_code.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if promotion_code.Promotion != nil {
		nestedData := make(map[string]interface{})
		if promotion_code.Promotion.Coupon != nil {
			nestedData["coupon"] = promotion_code.Promotion.Coupon.ID
		}
		nestedData["type"] = promotion_code.Promotion.Type
		if len(nestedData) > 0 {
			if err := d.Set("promotion", []interface{}{nestedData}); err != nil {
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	}
	if _, ok := d.GetOk("restrictions"); ok {
		if promotion_code.Restrictions != nil {
			nestedData := make(map[string]interface{})
			if promotion_code.Restrictions.CurrencyOptions != nil && len(promotion_code.Restrictions.CurrencyOptions) > 0 {
				itemsData := make([]interface{}, 0, len(promotion_code.Restrictions.CurrencyOptions))
				for k, item := range promotion_code.Restrictions.CurrencyOptions {
					itemData := make(map[string]interface{})
					itemData["key"] = k
					itemData["minimum_amount"] = int(item.MinimumAmount)
					if len(itemData) > 0 {
						itemsData = append(itemsData, itemData)
					}
				}
				if len(itemsData) > 0 {
					nestedData["currency_options"] = itemsData
				}
			}
			nestedData["first_time_transaction"] = promotion_code.Restrictions.FirstTimeTransaction
			nestedData["minimum_amount"] = int(promotion_code.Restrictions.MinimumAmount)
			if promotion_code.Restrictions.MinimumAmountCurrency != "" {
				nestedData["minimum_amount_currency"] = promotion_code.Restrictions.MinimumAmountCurrency
			}
			if len(nestedData) > 0 {
				if err := d.Set("restrictions", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	return diags
}

func resourcePromotionCodeUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_promotion_code resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.PromotionCodeUpdateParams{}

	if d.HasChange("active") {
		params.Active = stripe.Bool(d.Get("active").(bool))
	}
	if d.HasChange("metadata") {
		// Handle metadata updates including deletions
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = v.(string)
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = ""
			}
		}
	}
	if d.HasChange("restrictions") {
		if v, ok := d.Get("restrictions").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.Restrictions = &stripe.PromotionCodeUpdateRestrictionsParams{}
			if v, ok := data["currency_options"].([]interface{}); ok && len(v) > 0 {
				params.Restrictions.CurrencyOptions = make(map[string]*stripe.PromotionCodeUpdateRestrictionsCurrencyOptionsParams)
				for _, raw := range v {
					if item, ok := raw.(map[string]interface{}); ok {
						key, _ := item["key"].(string)
						if key == "" {
							continue
						}
						entry := &stripe.PromotionCodeUpdateRestrictionsCurrencyOptionsParams{}
						if val, ok := item["minimum_amount"].(int); ok {
							entry.MinimumAmount = stripe.Int64(int64(val))
						}
						params.Restrictions.CurrencyOptions[key] = entry
					}
				}
			}
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourcePromotionCodeRead(ctx, d, meta)
	}

	_, err := c.V1PromotionCodes.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update promotion_code: %w", err))
	}

	return resourcePromotionCodeRead(ctx, d, meta)
}

func resourcePromotionCodeDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Marking stripe_promotion_code as inactive instead of deleting", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.PromotionCodeUpdateParams{
		Active: stripe.Bool(false),
	}

	_, err := c.V1PromotionCodes.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to mark promotion_code as inactive: %w", err))
	}

	tflog.Info(ctx, "stripe_promotion_code marked as inactive successfully", map[string]interface{}{"id": d.Id()})
	d.SetId("")
	return nil
}
