// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/stripe/stripe-go/v84"
)

// ResourceV2BillingServiceAction returns the schema for the stripe_v2_billing_service_action resource
func ResourceV2BillingServiceAction() *schema.Resource {
	return &schema.Resource{
		Description: "Manages a stripe_v2_billing_service_action resource in Stripe.",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"lookup_key": {
				Type:        schema.TypeString,
				Description: "An internal key you can use to search for this service action. Maximum length of 200 characters.",
				Optional:    true,
				Computed:    true,
			},
			"service_interval": {
				Type:        schema.TypeString,
				Description: "The interval for assessing service.",
				Required:    true,
				ForceNew:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"day",
					"month",
					"week",
					"year",
				}, false)),
			},
			"service_interval_count": {
				Type:        schema.TypeInt,
				Description: "The length of the interval for assessing service.",
				Required:    true,
				ForceNew:    true,
			},
			"type": {
				Type:        schema.TypeString,
				Description: "The type of the service action.",
				Required:    true,
				ForceNew:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"credit_grant",
					"credit_grant_per_tenant",
				}, false)),
			},
			"credit_grant": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Details for the credit grant. Required if `type` is `credit_grant`.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"amount": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Required:    true,
							Description: "The amount of the credit grant.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"custom_pricing_unit": {
										Type:        schema.TypeList,
										MaxItems:    1,
										Optional:    true,
										Description: "The custom pricing unit amount of the credit grant. Required if `type` is `custom_pricing_unit`.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"id": {
													Type:        schema.TypeString,
													Description: "The id of the custom pricing unit.",
													Required:    true,
												},
												"value": {
													Type:        schema.TypeString,
													Description: "The value of the credit grant, decimal value represented as a string.",
													Required:    true,
												},
											},
										},
									},
									"monetary": {
										Type:        schema.TypeList,
										MaxItems:    1,
										Optional:    true,
										Description: "The monetary amount of the credit grant. Required if `type` is `monetary`.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"amount": {
													Type:        schema.TypeInt,
													Description: "A non-negative integer representing how much to charge in the [smallest currency unit](https://docs.stripe.com/currencies#minor-units).",
													Optional:    true,
												},
												"currency": {
													Type:        schema.TypeString,
													Description: "Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).",
													Optional:    true,
												},
											},
										},
									},
									"type": {
										Type:        schema.TypeString,
										Description: "The type of the credit grant amount. We currently support `monetary` and `custom_pricing_unit` billing credits.",
										Required:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"custom_pricing_unit",
											"monetary",
										}, false)),
									},
								},
							},
						},
						"applicability_config": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Required:    true,
							Description: "Defines the scope where the credit grant is applicable.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"scope": {
										Type:        schema.TypeList,
										MaxItems:    1,
										Required:    true,
										Description: "The applicability scope of the credit grant.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"billable_items": {
													Type:        schema.TypeList,
													Description: "The billable items to apply the credit grant to.",
													Optional:    true,
													Elem:        &schema.Schema{Type: schema.TypeString},
												},
												"price_type": {
													Type:        schema.TypeString,
													Description: "The price type that credit grants can apply to. We currently only support the `metered` price type. This will apply to metered prices and rate cards. Cannot be used in combination with `billable_items`.",
													Optional:    true,
													ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
														"metered",
													}, false)),
												},
											},
										},
									},
								},
							},
						},
						"category": {
							Type:        schema.TypeString,
							Description: "The category of the credit grant.",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
								"paid",
								"promotional",
							}, false)),
						},
						"expiry_config": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Required:    true,
							Description: "The expiry configuration for the credit grant.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:        schema.TypeString,
										Description: "The type of the expiry configuration. We currently support `end_of_service_period`.",
										Required:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"end_of_service_period",
										}, false)),
									},
								},
							},
						},
						"name": {
							Type:        schema.TypeString,
							Description: "A descriptive name shown in dashboard.",
							Required:    true,
						},
						"priority": {
							Type:        schema.TypeInt,
							Description: "The desired priority for applying this credit grant. If not specified, it will be set to the default value of 50. The highest priority is 0 and the lowest is 100.",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
						},
					},
				},
			},
		},

		CreateContext: resourceV2BillingServiceActionCreate,
		ReadContext:   resourceV2BillingServiceActionRead,
		UpdateContext: resourceV2BillingServiceActionUpdate,
		DeleteContext: resourceV2BillingServiceActionDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceV2BillingServiceActionCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_v2_billing_service_action resource")
	c := meta.(*stripe.Client)

	params := &stripe.V2BillingServiceActionCreateParams{}

	if v, ok := d.Get("lookup_key").(string); ok && v != "" {
		params.LookupKey = stripe.String(v)
	}
	if v, ok := d.Get("service_interval").(string); ok && v != "" {
		params.ServiceInterval = stripe.String(v)
	}
	params.ServiceIntervalCount = stripe.Int64(int64(d.Get("service_interval_count").(int)))
	if v, ok := d.Get("type").(string); ok && v != "" {
		params.Type = stripe.String(v)
	}
	if v, ok := d.Get("credit_grant").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.CreditGrant = &stripe.V2BillingServiceActionCreateCreditGrantParams{}
		if v, ok := data["amount"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.CreditGrant.Amount = &stripe.V2BillingServiceActionCreateCreditGrantAmountParams{}
			if v, ok := nestedData0["custom_pricing_unit"].([]interface{}); ok && len(v) > 0 {
				nestedData1 := v[0].(map[string]interface{})
				params.CreditGrant.Amount.CustomPricingUnit = &stripe.V2BillingServiceActionCreateCreditGrantAmountCustomPricingUnitParams{}
				if val, ok := nestedData1["id"].(string); ok && val != "" {
					params.CreditGrant.Amount.CustomPricingUnit.ID = stripe.String(val)
				}
				if val, ok := nestedData1["value"].(string); ok && val != "" {
					params.CreditGrant.Amount.CustomPricingUnit.Value = stripe.String(val)
				}
			}
			if v, ok := nestedData0["monetary"].([]interface{}); ok && len(v) > 0 {
				nestedData1 := v[0].(map[string]interface{})
				params.CreditGrant.Amount.Monetary = &stripe.V2BillingServiceActionCreateCreditGrantAmountMonetaryParams{}
				if val, ok := nestedData1["amount"].(int); ok && val > 0 {
					params.CreditGrant.Amount.Monetary.Value = stripe.Int64(int64(val))
				}
				if val, ok := nestedData1["currency"].(string); ok && val != "" {
					params.CreditGrant.Amount.Monetary.Currency = stripe.String(val)
				}
			}
			if val, ok := nestedData0["type"].(string); ok && val != "" {
				params.CreditGrant.Amount.Type = stripe.String(val)
			}
		}
		if v, ok := data["applicability_config"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.CreditGrant.ApplicabilityConfig = &stripe.V2BillingServiceActionCreateCreditGrantApplicabilityConfigParams{}
			if v, ok := nestedData0["scope"].([]interface{}); ok && len(v) > 0 {
				nestedData1 := v[0].(map[string]interface{})
				params.CreditGrant.ApplicabilityConfig.Scope = &stripe.V2BillingServiceActionCreateCreditGrantApplicabilityConfigScopeParams{}
				if val, ok := nestedData1["billable_items"].([]interface{}); ok && len(val) > 0 {
					strArr := make([]*string, len(val))
					for i, v := range val {
						if s, ok := v.(string); ok {
							strArr[i] = stripe.String(s)
						}
					}
					params.CreditGrant.ApplicabilityConfig.Scope.BillableItems = strArr
				}
				if val, ok := nestedData1["price_type"].(string); ok && val != "" {
					params.CreditGrant.ApplicabilityConfig.Scope.PriceType = stripe.String(val)
				}
			}
		}
		if val, ok := data["category"].(string); ok && val != "" {
			params.CreditGrant.Category = stripe.String(val)
		}
		if v, ok := data["expiry_config"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.CreditGrant.ExpiryConfig = &stripe.V2BillingServiceActionCreateCreditGrantExpiryConfigParams{}
			if val, ok := nestedData0["type"].(string); ok && val != "" {
				params.CreditGrant.ExpiryConfig.Type = stripe.String(val)
			}
		}
		if val, ok := data["name"].(string); ok && val != "" {
			params.CreditGrant.Name = stripe.String(val)
		}
		if val, ok := data["priority"].(int); ok && val > 0 {
			params.CreditGrant.Priority = stripe.Int64(int64(val))
		}
	}
	v2_billing_service_action, err := c.V2BillingServiceActions.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create v2_billing_service_action: %w", err))
	}

	d.SetId(v2_billing_service_action.ID)
	return resourceV2BillingServiceActionRead(ctx, d, meta)
}

func resourceV2BillingServiceActionRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_v2_billing_service_action resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	v2_billing_service_action, err := c.V2BillingServiceActions.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read v2_billing_service_action: %w", err))
	}

	if err := d.Set("lookup_key", v2_billing_service_action.LookupKey); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("service_interval", v2_billing_service_action.ServiceInterval); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("service_interval_count", v2_billing_service_action.ServiceIntervalCount); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("type", v2_billing_service_action.Type); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if _, ok := d.GetOk("credit_grant"); ok {
		if v2_billing_service_action.CreditGrant != nil {
			nestedData := make(map[string]interface{})
			if v2_billing_service_action.CreditGrant.Amount != nil {
				nestedData0 := make(map[string]interface{})
				if v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit != nil {
					nestedData1 := make(map[string]interface{})
					if v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails != nil {
						nestedData2 := make(map[string]interface{})
						nestedData2["active"] = v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails.Active
						if v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails.DisplayName != "" {
							nestedData2["display_name"] = v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails.DisplayName
						}
						if v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails.LookupKey != "" {
							nestedData2["lookup_key"] = v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.CustomPricingUnitDetails.LookupKey
						}
						nestedData1["custom_pricing_unit_details"] = []interface{}{nestedData2}
					}
					if v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.Value != "" {
						nestedData1["value"] = normalizeDecimalString(v2_billing_service_action.CreditGrant.Amount.CustomPricingUnit.Value)
					}
					nestedData0["custom_pricing_unit"] = []interface{}{nestedData1}
				}
				if v2_billing_service_action.CreditGrant.Amount.Monetary != nil {
					nestedData1 := make(map[string]interface{})
					nestedData1["amount"] = int(v2_billing_service_action.CreditGrant.Amount.Monetary.Value)
					if v2_billing_service_action.CreditGrant.Amount.Monetary.Currency != "" {
						nestedData1["currency"] = v2_billing_service_action.CreditGrant.Amount.Monetary.Currency
					}
					nestedData0["monetary"] = []interface{}{nestedData1}
				}
				if v2_billing_service_action.CreditGrant.Amount.Type != "" {
					nestedData0["type"] = v2_billing_service_action.CreditGrant.Amount.Type
				}
				nestedData["amount"] = []interface{}{nestedData0}
			}
			if v2_billing_service_action.CreditGrant.ApplicabilityConfig != nil {
				nestedData0 := make(map[string]interface{})
				if v2_billing_service_action.CreditGrant.ApplicabilityConfig.Scope != nil {
					nestedData1 := make(map[string]interface{})
					if v2_billing_service_action.CreditGrant.ApplicabilityConfig.Scope.PriceType != "" {
						nestedData1["price_type"] = v2_billing_service_action.CreditGrant.ApplicabilityConfig.Scope.PriceType
					}
					nestedData0["scope"] = []interface{}{nestedData1}
				}
				nestedData["applicability_config"] = []interface{}{nestedData0}
			}
			if v2_billing_service_action.CreditGrant.Category != "" {
				nestedData["category"] = v2_billing_service_action.CreditGrant.Category
			}
			if v2_billing_service_action.CreditGrant.ExpiryConfig != nil {
				nestedData0 := make(map[string]interface{})
				if v2_billing_service_action.CreditGrant.ExpiryConfig.Type != "" {
					nestedData0["type"] = v2_billing_service_action.CreditGrant.ExpiryConfig.Type
				}
				nestedData["expiry_config"] = []interface{}{nestedData0}
			}
			if v2_billing_service_action.CreditGrant.Name != "" {
				nestedData["name"] = v2_billing_service_action.CreditGrant.Name
			}
			nestedData["priority"] = int(v2_billing_service_action.CreditGrant.Priority)
			if len(nestedData) > 0 {
				if err := d.Set("credit_grant", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	return diags
}

func resourceV2BillingServiceActionUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_v2_billing_service_action resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.V2BillingServiceActionUpdateParams{}

	if d.HasChange("lookup_key") {
		if v, ok := d.Get("lookup_key").(string); ok && v != "" {
			params.LookupKey = stripe.String(v)
		}
	}
	if d.HasChange("credit_grant") {
		if v, ok := d.Get("credit_grant").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.CreditGrant = &stripe.V2BillingServiceActionUpdateCreditGrantParams{}
			if val, ok := data["name"].(string); ok && val != "" {
				params.CreditGrant.Name = stripe.String(val)
			}
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceV2BillingServiceActionRead(ctx, d, meta)
	}

	_, err := c.V2BillingServiceActions.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update v2_billing_service_action: %w", err))
	}

	return resourceV2BillingServiceActionRead(ctx, d, meta)
}

func resourceV2BillingServiceActionDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Warn(ctx, "stripe_v2_billing_service_action resources cannot be deleted via the Stripe API. "+
		"The resource will be removed from Terraform state but will remain in your Stripe account. "+
		"You may need to archive or deactivate it manually.",
		map[string]interface{}{"id": d.Id()})
	d.SetId("")
	return nil
}
