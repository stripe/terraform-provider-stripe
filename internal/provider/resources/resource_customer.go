// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/stripe/stripe-go/v84"
)

// ResourceCustomer returns the schema for the stripe_customer resource
func ResourceCustomer() *schema.Resource {
	return &schema.Resource{
		Description: "This object represents a customer of your business. Use it to [create recurring charges](https://stripe.com/docs/invoicing/customer), [save payment](https://stripe.com/docs/payments/save-during-payment) and contact information, and track payments that belong to the same customer.",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"balance": {
				Type:        schema.TypeInt,
				Description: "An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.",
				Optional:    true,
				Computed:    true,
			},
			"business_name": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"description": {
				Type:        schema.TypeString,
				Description: "An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.",
				Optional:    true,
				Computed:    true,
			},
			"email": {
				Type:        schema.TypeString,
				Description: "Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.",
				Optional:    true,
				Computed:    true,
			},
			"individual_name": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"invoice_prefix": {
				Type:        schema.TypeString,
				Description: "The prefix for the customer used to generate unique invoice numbers. Must be 3â€“12 uppercase letters or numbers.",
				Optional:    true,
				Computed:    true,
			},
			"metadata": {
				Type:     schema.TypeMap,
				Optional: true,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Description: "The customer's full name or business name.",
				Optional:    true,
				Computed:    true,
			},
			"next_invoice_sequence": {
				Type:        schema.TypeInt,
				Description: "The sequence to be used on the customer's next invoice. Defaults to 1.",
				Optional:    true,
				Computed:    true,
			},
			"phone": {
				Type:        schema.TypeString,
				Description: "The customer's phone number.",
				Optional:    true,
				Computed:    true,
			},
			"preferred_locales": {
				Type:        schema.TypeList,
				Description: "Customer's preferred languages, ordered by preference.",
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"tax_exempt": {
				Type:        schema.TypeString,
				Description: "The customer's tax exemption. One of `none`, `exempt`, or `reverse`.",
				Optional:    true,
				Computed:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"",
					"exempt",
					"none",
					"reverse",
				}, false)),
			},
			"test_clock": {
				Type:        schema.TypeString,
				Description: "ID of the test clock to attach to the customer.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"address": {
				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"city": {
							Type:        schema.TypeString,
							Description: "City, district, suburb, town, or village.",
							Optional:    true,
						},
						"country": {
							Type:        schema.TypeString,
							Description: "A freeform text field for the country. However, in order to activate some tax features, the format should be a two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).",
							Optional:    true,
						},
						"line1": {
							Type:        schema.TypeString,
							Description: "Address line 1, such as the street, PO Box, or company name.",
							Optional:    true,
						},
						"line2": {
							Type:        schema.TypeString,
							Description: "Address line 2, such as the apartment, suite, unit, or building.",
							Optional:    true,
						},
						"postal_code": {
							Type:        schema.TypeString,
							Description: "ZIP or postal code.",
							Optional:    true,
						},
						"state": {
							Type:        schema.TypeString,
							Description: "State, county, province, or region.",
							Optional:    true,
						},
					},
				},
			},
			"cash_balance": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Balance information and default balance settings for this customer.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"settings": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Optional:    true,
							Description: "Settings controlling the behavior of the customer's cash balance, such as reconciliation of funds received.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"reconciliation_mode": {
										Type:        schema.TypeString,
										Description: "Controls how funds transferred by the customer are applied to payment intents and invoices. Valid options are `automatic`, `manual`, or `merchant_default`. For more information about these reconciliation modes, see [Reconciliation](https://stripe.com/docs/payments/customer-balance/reconciliation).",
										Optional:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"automatic",
											"manual",
											"merchant_default",
										}, false)),
									},
								},
							},
						},
					},
				},
			},
			"invoice_settings": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Default invoice settings for this customer.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"custom_fields": {
							Type:     schema.TypeList,
							Optional: true,
							Elem:     &schema.Schema{Type: schema.TypeList},
						},
						"default_payment_method": {
							Type:        schema.TypeString,
							Description: "ID of a payment method that's attached to the customer, to be used as the customer's default payment method for subscriptions and invoices.",
							Optional:    true,
						},
						"footer": {
							Type:        schema.TypeString,
							Description: "Default footer to be displayed on invoices for this customer.",
							Optional:    true,
						},
						"rendering_options": {
							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"amount_tax_display": {
										Type:        schema.TypeString,
										Description: "How line-item prices and amounts will be displayed with respect to tax on invoice PDFs. One of `exclude_tax` or `include_inclusive_tax`. `include_inclusive_tax` will include inclusive tax (and exclude exclusive tax) in invoice PDF amounts. `exclude_tax` will exclude all tax (inclusive and exclusive alike) from invoice PDF amounts.",
										Optional:    true,
										ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
											"",
											"exclude_tax",
											"include_inclusive_tax",
										}, false)),
									},
									"template": {
										Type:        schema.TypeString,
										Description: "ID of the invoice rendering template to use for future invoices.",
										Optional:    true,
									},
								},
							},
						},
					},
				},
			},
			"shipping": {
				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeList,
							MaxItems:    1,
							Required:    true,
							Description: "Customer shipping address.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"city": {
										Type:        schema.TypeString,
										Description: "City, district, suburb, town, or village.",
										Optional:    true,
									},
									"country": {
										Type:        schema.TypeString,
										Description: "A freeform text field for the country. However, in order to activate some tax features, the format should be a two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).",
										Optional:    true,
									},
									"line1": {
										Type:        schema.TypeString,
										Description: "Address line 1, such as the street, PO Box, or company name.",
										Optional:    true,
									},
									"line2": {
										Type:        schema.TypeString,
										Description: "Address line 2, such as the apartment, suite, unit, or building.",
										Optional:    true,
									},
									"postal_code": {
										Type:        schema.TypeString,
										Description: "ZIP or postal code.",
										Optional:    true,
									},
									"state": {
										Type:        schema.TypeString,
										Description: "State, county, province, or region.",
										Optional:    true,
									},
								},
							},
						},
						"name": {
							Type:        schema.TypeString,
							Description: "Customer name.",
							Required:    true,
						},
						"phone": {
							Type:        schema.TypeString,
							Description: "Customer phone (including extension).",
							Optional:    true,
						},
					},
				},
			},
			"tax": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Tax details about the customer.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ip_address": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"validate_location": {
							Type:        schema.TypeString,
							Description: "A flag that indicates when Stripe should validate the customer tax location. Defaults to `deferred`.",
							Optional:    true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
								"deferred",
								"immediately",
							}, false)),
						},
					},
				},
			},
		},

		CreateContext: resourceCustomerCreate,
		ReadContext:   resourceCustomerRead,
		UpdateContext: resourceCustomerUpdate,
		DeleteContext: resourceCustomerDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceCustomerCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_customer resource")
	c := meta.(*stripe.Client)

	params := &stripe.CustomerCreateParams{}

	if !d.GetRawConfig().GetAttr("balance").IsNull() {
		params.Balance = stripe.Int64(int64(d.Get("balance").(int)))
	}
	if v, ok := d.Get("business_name").(string); ok && v != "" {
		params.BusinessName = stripe.String(v)
	}
	if v, ok := d.Get("description").(string); ok && v != "" {
		params.Description = stripe.String(v)
	}
	if v, ok := d.Get("email").(string); ok && v != "" {
		params.Email = stripe.String(v)
	}
	if v, ok := d.Get("individual_name").(string); ok && v != "" {
		params.IndividualName = stripe.String(v)
	}
	if v, ok := d.Get("invoice_prefix").(string); ok && v != "" {
		params.InvoicePrefix = stripe.String(v)
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("name").(string); ok && v != "" {
		params.Name = stripe.String(v)
	}
	if !d.GetRawConfig().GetAttr("next_invoice_sequence").IsNull() {
		params.NextInvoiceSequence = stripe.Int64(int64(d.Get("next_invoice_sequence").(int)))
	}
	if v, ok := d.Get("phone").(string); ok && v != "" {
		params.Phone = stripe.String(v)
	}
	if v, ok := d.Get("preferred_locales").([]interface{}); ok && len(v) > 0 {
		strArr := make([]*string, len(v))
		for i, item := range v {
			if s, ok := item.(string); ok {
				strArr[i] = stripe.String(s)
			}
		}
		params.PreferredLocales = strArr
	}
	if v, ok := d.Get("tax_exempt").(string); ok && v != "" {
		params.TaxExempt = stripe.String(v)
	}
	if v, ok := d.Get("test_clock").(string); ok && v != "" {
		params.TestClock = stripe.String(v)
	}
	if v, ok := d.Get("address").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Address = &stripe.AddressParams{}
		if val, ok := data["city"].(string); ok && val != "" {
			params.Address.City = stripe.String(val)
		}
		if val, ok := data["country"].(string); ok && val != "" {
			params.Address.Country = stripe.String(val)
		}
		if val, ok := data["line1"].(string); ok && val != "" {
			params.Address.Line1 = stripe.String(val)
		}
		if val, ok := data["line2"].(string); ok && val != "" {
			params.Address.Line2 = stripe.String(val)
		}
		if val, ok := data["postal_code"].(string); ok && val != "" {
			params.Address.PostalCode = stripe.String(val)
		}
		if val, ok := data["state"].(string); ok && val != "" {
			params.Address.State = stripe.String(val)
		}
	}
	if v, ok := d.Get("cash_balance").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.CashBalance = &stripe.CustomerCreateCashBalanceParams{}
		if v, ok := data["settings"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.CashBalance.Settings = &stripe.CustomerCreateCashBalanceSettingsParams{}
			if val, ok := nestedData0["reconciliation_mode"].(string); ok && val != "" {
				params.CashBalance.Settings.ReconciliationMode = stripe.String(val)
			}
		}
	}
	if v, ok := d.Get("invoice_settings").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.InvoiceSettings = &stripe.CustomerCreateInvoiceSettingsParams{}
		if val, ok := data["custom_fields"].([]interface{}); ok && len(val) > 0 {
			// TODO: Handle complex array conversion for custom_fields
		}
		if val, ok := data["default_payment_method"].(string); ok && val != "" {
			params.InvoiceSettings.DefaultPaymentMethod = stripe.String(val)
		}
		if val, ok := data["footer"].(string); ok && val != "" {
			params.InvoiceSettings.Footer = stripe.String(val)
		}
		if v, ok := data["rendering_options"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.InvoiceSettings.RenderingOptions = &stripe.CustomerCreateInvoiceSettingsRenderingOptionsParams{}
			if val, ok := nestedData0["amount_tax_display"].(string); ok && val != "" {
				params.InvoiceSettings.RenderingOptions.AmountTaxDisplay = stripe.String(val)
			}
			if val, ok := nestedData0["template"].(string); ok && val != "" {
				params.InvoiceSettings.RenderingOptions.Template = stripe.String(val)
			}
		}
	}
	if v, ok := d.Get("shipping").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Shipping = &stripe.CustomerCreateShippingParams{}
		if v, ok := data["address"].([]interface{}); ok && len(v) > 0 {
			nestedData0 := v[0].(map[string]interface{})
			params.Shipping.Address = &stripe.AddressParams{}
			if val, ok := nestedData0["city"].(string); ok && val != "" {
				params.Shipping.Address.City = stripe.String(val)
			}
			if val, ok := nestedData0["country"].(string); ok && val != "" {
				params.Shipping.Address.Country = stripe.String(val)
			}
			if val, ok := nestedData0["line1"].(string); ok && val != "" {
				params.Shipping.Address.Line1 = stripe.String(val)
			}
			if val, ok := nestedData0["line2"].(string); ok && val != "" {
				params.Shipping.Address.Line2 = stripe.String(val)
			}
			if val, ok := nestedData0["postal_code"].(string); ok && val != "" {
				params.Shipping.Address.PostalCode = stripe.String(val)
			}
			if val, ok := nestedData0["state"].(string); ok && val != "" {
				params.Shipping.Address.State = stripe.String(val)
			}
		}
		if val, ok := data["name"].(string); ok && val != "" {
			params.Shipping.Name = stripe.String(val)
		}
		if val, ok := data["phone"].(string); ok && val != "" {
			params.Shipping.Phone = stripe.String(val)
		}
	}
	if v, ok := d.Get("tax").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Tax = &stripe.CustomerCreateTaxParams{}
		if val, ok := data["ip_address"].(string); ok && val != "" {
			params.Tax.IPAddress = stripe.String(val)
		}
		if val, ok := data["validate_location"].(string); ok && val != "" {
			params.Tax.ValidateLocation = stripe.String(val)
		}
	}
	customer, err := c.V1Customers.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create customer: %w", err))
	}

	d.SetId(customer.ID)
	return resourceCustomerRead(ctx, d, meta)
}

func resourceCustomerRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_customer resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	customer, err := c.V1Customers.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read customer: %w", err))
	}

	if err := d.Set("balance", customer.Balance); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("business_name", customer.BusinessName); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("description", customer.Description); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("email", customer.Email); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("individual_name", customer.IndividualName); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("invoice_prefix", customer.InvoicePrefix); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", customer.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("name", customer.Name); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("next_invoice_sequence", customer.NextInvoiceSequence); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("phone", customer.Phone); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if customer.PreferredLocales != nil && len(customer.PreferredLocales) > 0 {
		if err := d.Set("preferred_locales", customer.PreferredLocales); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}
	if err := d.Set("tax_exempt", customer.TaxExempt); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("test_clock", customer.TestClock); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if _, ok := d.GetOk("address"); ok {
		if customer.Address != nil {
			nestedData := make(map[string]interface{})
			if customer.Address.City != "" {
				nestedData["city"] = customer.Address.City
			}
			if customer.Address.Country != "" {
				nestedData["country"] = customer.Address.Country
			}
			if customer.Address.Line1 != "" {
				nestedData["line1"] = customer.Address.Line1
			}
			if customer.Address.Line2 != "" {
				nestedData["line2"] = customer.Address.Line2
			}
			if customer.Address.PostalCode != "" {
				nestedData["postal_code"] = customer.Address.PostalCode
			}
			if customer.Address.State != "" {
				nestedData["state"] = customer.Address.State
			}
			if len(nestedData) > 0 {
				if err := d.Set("address", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("cash_balance"); ok {
		if customer.CashBalance != nil {
			nestedData := make(map[string]interface{})
			if customer.CashBalance.Customer != "" {
				nestedData["customer"] = customer.CashBalance.Customer
			}
			if customer.CashBalance.Settings != nil {
				nestedData0 := make(map[string]interface{})
				if customer.CashBalance.Settings.ReconciliationMode != "" {
					nestedData0["reconciliation_mode"] = customer.CashBalance.Settings.ReconciliationMode
				}
				nestedData0["using_merchant_default"] = customer.CashBalance.Settings.UsingMerchantDefault
				nestedData["settings"] = []interface{}{nestedData0}
			}
			if len(nestedData) > 0 {
				if err := d.Set("cash_balance", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("invoice_settings"); ok {
		if customer.InvoiceSettings != nil {
			nestedData := make(map[string]interface{})
			if customer.InvoiceSettings.DefaultPaymentMethod != nil {
				nestedData["default_payment_method"] = customer.InvoiceSettings.DefaultPaymentMethod.ID
			}
			if customer.InvoiceSettings.Footer != "" {
				nestedData["footer"] = customer.InvoiceSettings.Footer
			}
			if customer.InvoiceSettings.RenderingOptions != nil {
				nestedData0 := make(map[string]interface{})
				if customer.InvoiceSettings.RenderingOptions.AmountTaxDisplay != "" {
					nestedData0["amount_tax_display"] = customer.InvoiceSettings.RenderingOptions.AmountTaxDisplay
				}
				if customer.InvoiceSettings.RenderingOptions.Template != "" {
					nestedData0["template"] = customer.InvoiceSettings.RenderingOptions.Template
				}
				nestedData["rendering_options"] = []interface{}{nestedData0}
			}
			if len(nestedData) > 0 {
				if err := d.Set("invoice_settings", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("shipping"); ok {
		if customer.Shipping != nil {
			nestedData := make(map[string]interface{})
			if customer.Shipping.Address != nil {
				nestedData0 := make(map[string]interface{})
				if customer.Shipping.Address.City != "" {
					nestedData0["city"] = customer.Shipping.Address.City
				}
				if customer.Shipping.Address.Country != "" {
					nestedData0["country"] = customer.Shipping.Address.Country
				}
				if customer.Shipping.Address.Line1 != "" {
					nestedData0["line1"] = customer.Shipping.Address.Line1
				}
				if customer.Shipping.Address.Line2 != "" {
					nestedData0["line2"] = customer.Shipping.Address.Line2
				}
				if customer.Shipping.Address.PostalCode != "" {
					nestedData0["postal_code"] = customer.Shipping.Address.PostalCode
				}
				if customer.Shipping.Address.State != "" {
					nestedData0["state"] = customer.Shipping.Address.State
				}
				nestedData["address"] = []interface{}{nestedData0}
			}
			if customer.Shipping.Carrier != "" {
				nestedData["carrier"] = customer.Shipping.Carrier
			}
			if customer.Shipping.Name != "" {
				nestedData["name"] = customer.Shipping.Name
			}
			if customer.Shipping.Phone != "" {
				nestedData["phone"] = customer.Shipping.Phone
			}
			if customer.Shipping.TrackingNumber != "" {
				nestedData["tracking_number"] = customer.Shipping.TrackingNumber
			}
			if len(nestedData) > 0 {
				if err := d.Set("shipping", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("tax"); ok {
		if customer.Tax != nil {
			nestedData := make(map[string]interface{})
			if customer.Tax.AutomaticTax != "" {
				nestedData["automatic_tax"] = customer.Tax.AutomaticTax
			}
			if customer.Tax.IPAddress != "" {
				nestedData["ip_address"] = customer.Tax.IPAddress
			}
			if customer.Tax.Location != nil {
				nestedData0 := make(map[string]interface{})
				if customer.Tax.Location.Country != "" {
					nestedData0["country"] = customer.Tax.Location.Country
				}
				if customer.Tax.Location.Source != "" {
					nestedData0["source"] = customer.Tax.Location.Source
				}
				if customer.Tax.Location.State != "" {
					nestedData0["state"] = customer.Tax.Location.State
				}
				nestedData["location"] = []interface{}{nestedData0}
			}
			if customer.Tax.Provider != "" {
				nestedData["provider"] = customer.Tax.Provider
			}
			if len(nestedData) > 0 {
				if err := d.Set("tax", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	return diags
}

func resourceCustomerUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_customer resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.CustomerUpdateParams{}

	if d.HasChange("balance") {
		params.Balance = stripe.Int64(int64(d.Get("balance").(int)))
	}
	if d.HasChange("business_name") {
		if v, ok := d.Get("business_name").(string); ok && v != "" {
			params.BusinessName = stripe.String(v)
		}
	}
	if d.HasChange("description") {
		if v, ok := d.Get("description").(string); ok && v != "" {
			params.Description = stripe.String(v)
		}
	}
	if d.HasChange("email") {
		if v, ok := d.Get("email").(string); ok && v != "" {
			params.Email = stripe.String(v)
		}
	}
	if d.HasChange("individual_name") {
		if v, ok := d.Get("individual_name").(string); ok && v != "" {
			params.IndividualName = stripe.String(v)
		}
	}
	if d.HasChange("invoice_prefix") {
		if v, ok := d.Get("invoice_prefix").(string); ok && v != "" {
			params.InvoicePrefix = stripe.String(v)
		}
	}
	if d.HasChange("metadata") {
		// Handle metadata updates including deletions
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = v.(string)
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = ""
			}
		}
	}
	if d.HasChange("name") {
		if v, ok := d.Get("name").(string); ok && v != "" {
			params.Name = stripe.String(v)
		}
	}
	if d.HasChange("next_invoice_sequence") {
		params.NextInvoiceSequence = stripe.Int64(int64(d.Get("next_invoice_sequence").(int)))
	}
	if d.HasChange("phone") {
		if v, ok := d.Get("phone").(string); ok && v != "" {
			params.Phone = stripe.String(v)
		}
	}
	if d.HasChange("preferred_locales") {
		if v, ok := d.Get("preferred_locales").([]interface{}); ok && len(v) > 0 {
			strArr := make([]*string, len(v))
			for i, item := range v {
				if s, ok := item.(string); ok {
					strArr[i] = stripe.String(s)
				}
			}
			params.PreferredLocales = strArr
		}
	}
	if d.HasChange("tax_exempt") {
		if v, ok := d.Get("tax_exempt").(string); ok && v != "" {
			params.TaxExempt = stripe.String(v)
		}
	}
	if d.HasChange("address") {
		if v, ok := d.Get("address").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.Address = &stripe.AddressParams{}
			if val, ok := data["city"].(string); ok && val != "" {
				params.Address.City = stripe.String(val)
			}
			if val, ok := data["country"].(string); ok && val != "" {
				params.Address.Country = stripe.String(val)
			}
			if val, ok := data["line1"].(string); ok && val != "" {
				params.Address.Line1 = stripe.String(val)
			}
			if val, ok := data["line2"].(string); ok && val != "" {
				params.Address.Line2 = stripe.String(val)
			}
			if val, ok := data["postal_code"].(string); ok && val != "" {
				params.Address.PostalCode = stripe.String(val)
			}
			if val, ok := data["state"].(string); ok && val != "" {
				params.Address.State = stripe.String(val)
			}
		}
	}
	if d.HasChange("cash_balance") {
		if v, ok := d.Get("cash_balance").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.CashBalance = &stripe.CustomerUpdateCashBalanceParams{}
			if v, ok := data["settings"].([]interface{}); ok && len(v) > 0 {
				nestedData0 := v[0].(map[string]interface{})
				params.CashBalance.Settings = &stripe.CustomerUpdateCashBalanceSettingsParams{}
				if val, ok := nestedData0["reconciliation_mode"].(string); ok && val != "" {
					params.CashBalance.Settings.ReconciliationMode = stripe.String(val)
				}
			}
		}
	}
	if d.HasChange("invoice_settings") {
		if v, ok := d.Get("invoice_settings").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.InvoiceSettings = &stripe.CustomerUpdateInvoiceSettingsParams{}
			if val, ok := data["default_payment_method"].(string); ok && val != "" {
				params.InvoiceSettings.DefaultPaymentMethod = stripe.String(val)
			}
			if val, ok := data["footer"].(string); ok && val != "" {
				params.InvoiceSettings.Footer = stripe.String(val)
			}
			if v, ok := data["rendering_options"].([]interface{}); ok && len(v) > 0 {
				nestedData0 := v[0].(map[string]interface{})
				params.InvoiceSettings.RenderingOptions = &stripe.CustomerUpdateInvoiceSettingsRenderingOptionsParams{}
				if val, ok := nestedData0["amount_tax_display"].(string); ok && val != "" {
					params.InvoiceSettings.RenderingOptions.AmountTaxDisplay = stripe.String(val)
				}
				if val, ok := nestedData0["template"].(string); ok && val != "" {
					params.InvoiceSettings.RenderingOptions.Template = stripe.String(val)
				}
			}
		}
	}
	if d.HasChange("shipping") {
		if v, ok := d.Get("shipping").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.Shipping = &stripe.CustomerUpdateShippingParams{}
			if v, ok := data["address"].([]interface{}); ok && len(v) > 0 {
				nestedData0 := v[0].(map[string]interface{})
				params.Shipping.Address = &stripe.AddressParams{}
				if val, ok := nestedData0["city"].(string); ok && val != "" {
					params.Shipping.Address.City = stripe.String(val)
				}
				if val, ok := nestedData0["country"].(string); ok && val != "" {
					params.Shipping.Address.Country = stripe.String(val)
				}
				if val, ok := nestedData0["line1"].(string); ok && val != "" {
					params.Shipping.Address.Line1 = stripe.String(val)
				}
				if val, ok := nestedData0["line2"].(string); ok && val != "" {
					params.Shipping.Address.Line2 = stripe.String(val)
				}
				if val, ok := nestedData0["postal_code"].(string); ok && val != "" {
					params.Shipping.Address.PostalCode = stripe.String(val)
				}
				if val, ok := nestedData0["state"].(string); ok && val != "" {
					params.Shipping.Address.State = stripe.String(val)
				}
			}
			if val, ok := data["name"].(string); ok && val != "" {
				params.Shipping.Name = stripe.String(val)
			}
			if val, ok := data["phone"].(string); ok && val != "" {
				params.Shipping.Phone = stripe.String(val)
			}
		}
	}
	if d.HasChange("tax") {
		if v, ok := d.Get("tax").([]interface{}); ok && len(v) > 0 {
			data := v[0].(map[string]interface{})
			params.Tax = &stripe.CustomerUpdateTaxParams{}
			if val, ok := data["ip_address"].(string); ok && val != "" {
				params.Tax.IPAddress = stripe.String(val)
			}
			if val, ok := data["validate_location"].(string); ok && val != "" {
				params.Tax.ValidateLocation = stripe.String(val)
			}
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceCustomerRead(ctx, d, meta)
	}

	_, err := c.V1Customers.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update customer: %w", err))
	}

	return resourceCustomerRead(ctx, d, meta)
}

func resourceCustomerDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Deleting stripe_customer resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	_, err := c.V1Customers.Delete(ctx, d.Id(), nil)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to delete customer: %w", err))
	}

	d.SetId("")
	return nil
}
