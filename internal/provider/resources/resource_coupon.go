// Code generated by stripe-terraform generator. DO NOT EDIT.

package resources

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/stripe/stripe-go/v84"
)

// ResourceCoupon returns the schema for the stripe_coupon resource
func ResourceCoupon() *schema.Resource {
	return &schema.Resource{
		Description: "A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to [subscriptions](https://stripe.com/docs/api#subscriptions), [invoices](https://stripe.com/docs/api#invoices), [checkout sessions](https://stripe.com/docs/api/checkout/sessions), [quotes](https://stripe.com/docs/api#quotes), and more. Coupons do not work with conventional one-off [charges](https://stripe.com/docs/api#create_charge) or [payment intents](https://stripe.com/docs/api/payment_intents).",

		Schema: map[string]*schema.Schema{
			"id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"amount_off": {
				Type:        schema.TypeInt,
				Description: "A positive integer representing the amount to subtract from an invoice total (required if `percent_off` is not passed).",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"currency": {
				Type:        schema.TypeString,
				Description: "Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the `amount_off` parameter (required if `amount_off` is passed).",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"currency_options": {
				Type:        schema.TypeList,
				Description: "Coupons defined in each available currency option (only supported if `amount_off` is passed). Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).",
				Optional:    true,
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key": {
							Type:     schema.TypeString,
							Required: true,
						},
						"amount_off": {
							Type:        schema.TypeInt,
							Description: "A positive integer representing the amount to subtract from an invoice total.",
							Required:    true,
						},
					},
				},
			},
			"duration": {
				Type:        schema.TypeString,
				Description: "Specifies how long the discount will be in effect if used on a subscription. Defaults to `once`.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
					"forever",
					"once",
					"repeating",
				}, false)),
			},
			"duration_in_months": {
				Type:        schema.TypeInt,
				Description: "Required only if `duration` is `repeating`, in which case it must be a positive integer that specifies the number of months the discount will be in effect.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"max_redemptions": {
				Type:        schema.TypeInt,
				Description: "A positive integer specifying the number of times the coupon can be redeemed before it's no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"metadata": {
				Type:     schema.TypeMap,
				Optional: true,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Description: "Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.",
				Optional:    true,
				Computed:    true,
			},
			"percent_off": {
				Type:        schema.TypeFloat,
				Description: "A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if `amount_off` is not passed).",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"redeem_by": {
				Type:        schema.TypeInt,
				Description: "Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.",
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"applies_to": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				ForceNew:    true,
				Description: "A hash containing directions for what this Coupon will apply discounts to.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"products": {
							Type:        schema.TypeList,
							Description: "An array of Product IDs that this Coupon will apply to.",
							Optional:    true,
							Computed:    true,
							ForceNew:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"script": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				ForceNew:    true,
				Description: "Configuration of the [script](https://docs.stripe.com/billing/subscriptions/script-coupons) used to calculate the discount.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"configuration": {
							Type:        schema.TypeMap,
							Description: "The configuration values of the script. The keys and values are specific to the script implementation.",
							Required:    true,
							ForceNew:    true,
						},
						"id": {
							Type:        schema.TypeString,
							Description: "The script implementation ID for this coupon.",
							Required:    true,
							ForceNew:    true,
						},
					},
				},
			},
		},

		CreateContext: resourceCouponCreate,
		ReadContext:   resourceCouponRead,
		UpdateContext: resourceCouponUpdate,
		DeleteContext: resourceCouponDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceCouponCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Creating stripe_coupon resource")
	c := meta.(*stripe.Client)

	params := &stripe.CouponCreateParams{}

	if !d.GetRawConfig().GetAttr("amount_off").IsNull() {
		params.AmountOff = stripe.Int64(int64(d.Get("amount_off").(int)))
	}
	if v, ok := d.Get("currency").(string); ok && v != "" {
		params.Currency = stripe.String(v)
	}
	if v, ok := d.Get("duration").(string); ok && v != "" {
		params.Duration = stripe.String(v)
	}
	if !d.GetRawConfig().GetAttr("duration_in_months").IsNull() {
		params.DurationInMonths = stripe.Int64(int64(d.Get("duration_in_months").(int)))
	}
	if !d.GetRawConfig().GetAttr("max_redemptions").IsNull() {
		params.MaxRedemptions = stripe.Int64(int64(d.Get("max_redemptions").(int)))
	}
	if v, ok := d.Get("metadata").(map[string]interface{}); ok && len(v) > 0 {
		params.Metadata = make(map[string]string)
		for k, val := range v {
			params.Metadata[k] = val.(string)
		}
	}
	if v, ok := d.Get("name").(string); ok && v != "" {
		params.Name = stripe.String(v)
	}
	if !d.GetRawConfig().GetAttr("percent_off").IsNull() {
		params.PercentOff = stripe.Float64(d.Get("percent_off").(float64))
	}
	if !d.GetRawConfig().GetAttr("redeem_by").IsNull() {
		params.RedeemBy = stripe.Int64(int64(d.Get("redeem_by").(int)))
	}
	if v, ok := d.Get("applies_to").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.AppliesTo = &stripe.CouponCreateAppliesToParams{}
		if val, ok := data["products"].([]interface{}); ok && len(val) > 0 {
			strArr := make([]*string, len(val))
			for i, v := range val {
				if s, ok := v.(string); ok {
					strArr[i] = stripe.String(s)
				}
			}
			params.AppliesTo.Products = strArr
		}
	}
	if v, ok := d.Get("script").([]interface{}); ok && len(v) > 0 {
		data := v[0].(map[string]interface{})
		params.Script = &stripe.CouponCreateScriptParams{}
		if val, ok := data["id"].(string); ok && val != "" {
			params.Script.ID = stripe.String(val)
		}
	}
	if v, ok := d.Get("currency_options").([]interface{}); ok && len(v) > 0 {
		params.CurrencyOptions = make(map[string]*stripe.CouponCreateCurrencyOptionsParams)
		for _, raw := range v {
			if item, ok := raw.(map[string]interface{}); ok {
				key, _ := item["key"].(string)
				if key == "" {
					continue
				}
				entry := &stripe.CouponCreateCurrencyOptionsParams{}
				if val, ok := item["amount_off"].(int); ok {
					entry.AmountOff = stripe.Int64(int64(val))
				}
				params.CurrencyOptions[key] = entry
			}
		}
	}
	coupon, err := c.V1Coupons.Create(ctx, params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to create coupon: %w", err))
	}

	d.SetId(coupon.ID)
	return resourceCouponRead(ctx, d, meta)
}

func resourceCouponRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	tflog.Debug(ctx, "Reading stripe_coupon resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	coupon, err := c.V1Coupons.Retrieve(ctx, d.Id(), nil)
	if err != nil {
		// Check if it's a 404 (resource was deleted) vs other errors
		if stripeErr, ok := err.(*stripe.Error); ok && stripeErr.HTTPStatusCode == 404 {
			// Resource was deleted
			d.SetId("")
			return diags
		}
		// Other errors should be returned as diagnostics
		return diag.FromErr(fmt.Errorf("failed to read coupon: %w", err))
	}

	if err := d.Set("amount_off", coupon.AmountOff); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("currency", coupon.Currency); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if coupon.CurrencyOptions != nil && len(coupon.CurrencyOptions) > 0 {
		itemsData := make([]interface{}, 0, len(coupon.CurrencyOptions))
		for k, item := range coupon.CurrencyOptions {
			if item == nil {
				continue
			}
			itemData := make(map[string]interface{})
			itemData["key"] = k
			itemData["amount_off"] = int(item.AmountOff)
			if len(itemData) > 0 {
				itemsData = append(itemsData, itemData)
			}
		}
		if err := d.Set("currency_options", itemsData); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}
	if err := d.Set("duration", coupon.Duration); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("duration_in_months", coupon.DurationInMonths); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("max_redemptions", coupon.MaxRedemptions); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("metadata", coupon.Metadata); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("name", coupon.Name); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("percent_off", coupon.PercentOff); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if err := d.Set("redeem_by", coupon.RedeemBy); err != nil {
		diags = append(diags, diag.FromErr(err)...)
	}
	if _, ok := d.GetOk("applies_to"); ok {
		if coupon.AppliesTo != nil {
			nestedData := make(map[string]interface{})
			if len(nestedData) > 0 {
				if err := d.Set("applies_to", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	if _, ok := d.GetOk("script"); ok {
		if coupon.Script != nil {
			nestedData := make(map[string]interface{})
			nestedData["display_name"] = coupon.Script.DisplayName
			nestedData["id"] = coupon.Script.ID
			if len(nestedData) > 0 {
				if err := d.Set("script", []interface{}{nestedData}); err != nil {
					diags = append(diags, diag.FromErr(err)...)
				}
			}
		}
	}
	return diags
}

func resourceCouponUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Updating stripe_coupon resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	params := &stripe.CouponUpdateParams{}

	if d.HasChange("metadata") {
		// Handle metadata updates including deletions
		old, new := d.GetChange("metadata")
		oldMap := make(map[string]string)
		if old != nil {
			if oldMeta, ok := old.(map[string]interface{}); ok {
				for k, v := range oldMeta {
					oldMap[k] = v.(string)
				}
			}
		}
		params.Metadata = make(map[string]string)
		// Add/update keys from new metadata
		if new != nil {
			if newMeta, ok := new.(map[string]interface{}); ok {
				for k, v := range newMeta {
					params.Metadata[k] = v.(string)
				}
			}
		}
		// Mark removed keys for deletion by setting to empty string
		for k := range oldMap {
			if _, exists := params.Metadata[k]; !exists {
				params.Metadata[k] = ""
			}
		}
	}
	if d.HasChange("name") {
		if v, ok := d.Get("name").(string); ok && v != "" {
			params.Name = stripe.String(v)
		}
	}
	if d.HasChange("currency_options") {
		if v, ok := d.Get("currency_options").([]interface{}); ok && len(v) > 0 {
			params.CurrencyOptions = make(map[string]*stripe.CouponUpdateCurrencyOptionsParams)
			for _, raw := range v {
				if item, ok := raw.(map[string]interface{}); ok {
					key, _ := item["key"].(string)
					if key == "" {
						continue
					}
					entry := &stripe.CouponUpdateCurrencyOptionsParams{}
					if val, ok := item["amount_off"].(int); ok {
						entry.AmountOff = stripe.Int64(int64(val))
					}
					params.CurrencyOptions[key] = entry
				}
			}
		}
	}
	// Skip update if no fields were actually changed
	// This handles cases where fields are removed from config (HasChange returns true but new value is empty)
	if !paramsHasFields(params) {
		return resourceCouponRead(ctx, d, meta)
	}

	_, err := c.V1Coupons.Update(ctx, d.Id(), params)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to update coupon: %w", err))
	}

	return resourceCouponRead(ctx, d, meta)
}

func resourceCouponDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Debug(ctx, "Deleting stripe_coupon resource", map[string]interface{}{"id": d.Id()})
	c := meta.(*stripe.Client)

	_, err := c.V1Coupons.Delete(ctx, d.Id(), nil)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to delete coupon: %w", err))
	}

	d.SetId("")
	return nil
}
